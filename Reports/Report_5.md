# Topic: Parser & Building an Abstract Syntax Tree

## Course: Formal Languages & Finite Automata

### Author: Carp Dan-Octavian

#### Variant: 7

## Theory
A parser is a software component that analyzes the structure of input code based on a set of rules defined in a grammar. Takes a set of tokens (generated by a lexer) as input and determines if the code conforms to the defined grammar. Parsers can be implemented using various techniques such as: B. Recursive descent, LL, LR, or parser combinators. A parser processes input code, builds a parse tree or abstract syntax tree (AST), and can generate error messages if the input violates the grammar.

AST is a tree-like structure that represents the hierarchical syntactic structure of the input code. Capture key components of your code such as expressions, statements and declarations in a form suitable for further analysis and transformation. Each node in the AST corresponds to a construct in the code and contains information about the type of construct and its relationship to other constructs. ASTs are commonly used by programming language compilers and interpreters to perform tasks such as type checking, optimization, and code generation.Â 


## Objectives:
1. Get familiar with parsing, what it is and how it can be programmed [1].
2. Get familiar with the concept of AST [2].
3. In addition to what has been done in the 3rd lab work do the following:
   1. In case you didn't have a type that denotes the possible types of tokens you need to:
      1. Have a type __*TokenType*__ (like an enum) that can be used in the lexical analysis to categorize the tokens. 
      2. Please use regular expressions to identify the type of the token.
   2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
   3. Implement a simple parser program that could extract the syntactic information from the input text.


## Implementation 
```
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.token_index = 0
```
This part of the code defines a `Parser` class with with a list of tokens, setting the initial token index to 0 which keeps track and processes the tokens during operations.

We create a `Parser` class in which we define a contructor that takes the parameter `tokens ` which represents the list of tokens. We then assign the input `tokens` into the instacce variable `self_token`, making it accesible through the class. `self.token_index` keeps track of the current position index of the token being processed 
```
       def parse(self):
        try:
            ast = self.assignment()
            print("Parsing completed successfully.")
            return ast
        except ValueError as e:
            print("Parsing error:", str(e))

```
The purpose of the "parse" method is to initiate the parsing process by calling the assignment method, which parses an assignment statement and constructs an Abstract Syntax Tree (AST). It handles any potential parsing errors by catching ValueError exceptions and displaying an appropriate error message. If the parsing is successful, it prints a success message and returns the generated AST.

```
        def match(self, token_type):
        if self.token_index < len(self.tokens):
            token = self.tokens[self.token_index]
            if token[0] == token_type:
                self.token_index += 1
                return token
            else:
                raise ValueError(f"Expected '{token_type}', but got '{token[0]}'")
        else:
            raise ValueError(f"Expected '{token_type}', but reached end of input")

```
The match method is a vital component of the parsing process. It compares token types to ensure the parser progresses accurately. It handles different scenarios diligently and provides clear error messages when expectations are not met. It ensures that tokens are not missed and raises an error when the end of input is reached without finding the expected token type. Overall, the match method enhances the parser's robustness and allows it to navigate through code effectively.
```
       def assignment(self):
        identifier_token = self.match('Identifier')
        self.match('Operator')
        expression_ast = self.expression()
        self.match('Separator')
        return ('Assignment', identifier_token[1], expression_ast)
```
 The code assignment statement is managed by the assignment method. It retrieves identifiers, expressions and separators to form a structured representation of the assignment statement. This method ensures that tokens are in the correct place and have the right type, such as identifiers associated with operators, symbols or delimiters. In this way the assignment statement is represented in a legitimate manner and can be processed.. <br>


First line uses the `match` method to ensure that the next token is an identifier. It retrieves the identifier token and assigns it to the `identifier_token` variable.
 Next line checks that the next token is the assignment operator. Since the return value of `match` is not stored, it is used here to verify the presence of the operator without capturing its value.Next invoke the `expression` method, which recursively parses the expression on the right-hand side of the assignment. It returns the resulting abstract syntax tree (AST) of the expression, which is assigned to the` expression_ast` variable.
The forth line ensures that the next token is the separator, typically a semicolon. It verifies the presence of the separator but doesn't store its value.Laslty it constructs and returns an AST node representing the assignment statement. The AST node is a tuple with the first element being the string `Assignment`, followed by the identifier token value and the AST of the expression.
```
   def expression(self):
        term_ast = self.term()
        while self.token_index < len(self.tokens) and self.tokens[self.token_index][0] == 'Operator':
            operator_token = self.match('Operator')
            term_ast = ('Expression', term_ast, operator_token[1], self.term())
        return term_ast
```
The purpose of the `expresion`  method is to  take the expression in the code and break it down into smaller parts, creating a tree structure that shows how those parts are related to each other.


It starts by figuring out the first part of the expression and creates a tree node for it.
Then it looks at the next part of the expression and checks if it's an operator. If it is, it creates another tree node that represents the operator and combines it with the previous part of the expression.
It keeps doing this for any subsequent parts of the expression that are operators and terms, creating more tree nodes and connecting them together.
Finally, it returns the completed tree node that represents the entire expression.


```
    def term(self):
        factor_ast = self.factor()
        if self.token_index < len(self.tokens) and self.tokens[self.token_index][0] == 'Operator':
            operator_token = self.match('Operator')
            factor_ast = ('Term', factor_ast, operator_token[1], self.factor())
        return factor_ast
```

The `term` function serves the same objective as the `expression` function, although it is utilized for distinct mathematical computations. 
The function commences by invoking a different function known as "factor" to calculate the initial factor in the term. 
The `term` function carries out a computation of a term in a mathematical expression from left to right, considering multiplication and division operations.


```
  def factor(self):
        if self.token_index < len(self.tokens):
            token = self.tokens[self.token_index]
            self.token_index += 1
            if token[0] in ('Identifier', 'Literal'):
                return token[1]
            elif token[0] == 'Lparen':
                expression_ast = self.expression()
                self.match('Rparen')
                return expression_ast
        raise ValueError("Invalid factor")

```




The "factorization" technique manages the analysis and computation of factors in an arithmetic expression. Factors can be numerical values or sub-expressions confined within brackets. 
In case the token is categorized as "Numeric", it signifies a numerical value. 
If the token is classified as "LeftBracket", it denotes an opening bracket. The program updates the position and then calls the expr technique recursively to evaluate the expression confined within the brackets. 
The subsequent token is categorized as "RightBracket" (which denotes a closing bracket). If it is not, an error is triggered indicating a missing closing bracket. 
If the current token does not correspond to either "Numeric" or "LeftBracket", it implies an invalid syntax. The program generates an error with a message indicating the invalid token.


```

def build_ast(input_string):
    tokens = lexer(input_string)
    parser = Parser(tokens)
    return parser.parse()

```


The build_ast function takes an input string, breaks it down into tokens, and uses those tokens to construct an Abstract Syntax Tree (AST) that represents the structure of the code. It acts like a translator and puzzle solver, transforming the input into a more organized and meaningful form. The purpose is to facilitate further processing and understanding of the code.




## Conclusion
Implementing a parser for a specific grammar and working with Abstract Syntax Trees (ASTs) has provided valuable insights into code analysis and manipulation. ASTs offer a structured representation of code, simplifying tasks such as compilation and interpretation. By constructing ASTs, we can easily analyze and transform code, enabling various optimizations and static analysis

    
    
 ##Output
 ```
 ---------------------------------------------------------------------------------
Parsing completed successfully.
AST: ('Assignment', 'd', ('Expression', ('Term', ('Term', 'b', '*', 'b'), '-', '4'), '*', ('Term', 'a', '*', 'c')))
---------------------------------------------------------------------------------

 
 ```
 
 
 ##References
[1] [Parsing Wiki](https://en.wikipedia.org/wiki/Parsing)

[2] [Abstract Syntax Tree Wiki](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
